Устные вопросы:

Какой самый эффективный способ конкатенации строк?

Ответ:

    Если длина строк известна, то самый эффективный способ - использовать copy()
    
    В остальных случаях самый эффективный способ - использование strings.Builder.WriteString()

Что такое интерфейсы, как они применяются в Go?

Ответ:

    Интерфейсы являются наборами определенных методов.
    Они применяются для обобщения классов, реализующих один и тот же интерфейс.

Чем отличаются RWMutex от Mutex?

Ответ:
    
    В отличие от обычного Mutex, у RWMutex есть два метода блокировки - Lock() и RLock().
    При вызове RLock() только вызовы Lock() в других горутинах будут блокироваться, RLock() будут пропускаться.
    При вызове RUnlock() вызовы Lock() продолжат поочередно блокировать горутины.

Чем отличаются буферизированные и не буферизированные каналы?

Ответ:

    По умолчанию все каналы являются небуферизованными.
    Небуферизованный канал блокируется при попытке записать данные в канал, куда уже были записаны данные, но не были получены.
    Буферизованные каналы позволяют хранить в себе определенное количество данных, не блокируя поток при записи, пока канал не заполнится.

Какой размер у структуры struct{}{}?

Ответ:

    0

Есть ли в Go перегрузка методов или операторов?

Ответ:

    Нет


В какой последовательности будут выведены элементы map[int]int?

Пример:

    m[0]=1
    m[1]=124
    m[2]=281

Ответ:

    В случайном порядке
    


В чем разница make и new?

Ответ:

    Функция new выделяет в памяти пустую ячейку для хранения указанных данных и возвращает указатель на нее.
    Функция make используется только для объявления slice, map и chan и не возвращает указатель, также в make можно указать размер создаваемого объекта.


Сколько существует способов задать переменную типа slice или map?

Ответ:

    Объявить явно:
    sampleSlice:=[]int{1,2,3,4,5}

    sampleMap:=map[int]int{1:1,2:2,3:3,4:4,5:5}

    Объявить через make:
    sampleSlice:=make([]int,5)

    sampleMap:=make(map[int]int)

    Также слайс можно объявить на основе массива:
    arr:=[6]int{1,2,3,4,5,6}
    slice:=arr[:]


Что выведет данная программа и почему?

    func update(p *int) {
        b := 2
        p = &b
    }
    
    func main() {
        var (
            a = 1
            p = &a
        )
        fmt.Println(*p)
        update(p)
        fmt.Println(*p)
    }

Ответ:

    1
    1

    Потому что при вызове функции update переменная p переопределяется внутри функции, а не внутри main.

Что выведет данная программа и почему?

    func main() {
        wg := sync.WaitGroup{}
        for i := 0; i < 5; i++ {
            wg.Add(1)
            go func(wg sync.WaitGroup, i int) {
                fmt.Println(i)
                wg.Done()
            }(wg, i)
        }
        wg.Wait()
        fmt.Println("exit")
    }

Ответ:

    Числа от 0 до 4 в случайном порядке, а затем deadlock

    Потому что в качестве параметра функции, вызываемой в горутине, передается объект sync.WaitGroup, а не указатель на него.
    В результате этого метод Done не уменьшает счетчик WaitGroup в главной горутине и при вызове метода Wait() происходит deadlock.

Что выведет данная программа и почему?

    func main() {
        n := 0
        if true {
            n := 1
            n++
        }
        fmt.Println(n)
    }

Ответ:

    0

    Потому что n переопределяется внутри if, но вне условия n остается нулем.

Что выведет данная программа и почему?

    func someAction(v []int8, b int8) {
        v[0] = 100
        v = append(v, b)
    }
    
    func main() {
        var a = []int8{1, 2, 3, 4, 5}
        someAction(a, 6)
        fmt.Println(a)
    }

Ответ:

    [100 2 3 4 5]

    Потому что внутри функции someAction v[0] меняется на 100, v[0] - указатель.
    Затем v значение v внутри функции меняется на append(v,b), v не является указателем, поэтому в main значение v остается неизменным.

Что выведет данная программа и почему?

    func main() {
        slice := []string{"a", "a"}
        func(slice []string) {
            slice = append(slice, "a")
            slice[0] = "b"
            slice[1] = "b"
            fmt.Print(slice)
        }(slice)
        fmt.Print(slice)
    }

Ответ:

    [b b a][a a]

    Потому что внутри анонимной функции значение slice сразу меняется на append(slice,"a").
    Так как в функцию был передан не указатель, а сам слайс, первая строчка переопределила переменную slice внутри функции, она перестала быть связана с переменной slice в main.
    Затем первые два элемента slice внутри функции меняются на "b", но внутри main переменная slice останется неизменной.
    При вызове fmt.Print(slice) внутри функции и вне ее, будет выведено два разных значения.


